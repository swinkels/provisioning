# -*- mode: Makefile -*-
# -*- eval: (outline-minor-mode); outline-regexp: "# [*]+"; -*-

# * Includes and main variables

AVAILABLE_PACKAGES=curl

include Makefile.shared

ifneq ($(words $(MAKECMDGOALS)), 1)
$(error Exactly one target should be passed to Makefile.build)
endif

PACKAGE=$(foreach PKG,$(AVAILABLE_PACKAGES),$(findstring $(PKG),$(MAKECMDGOALS)))

ifneq ($(words $(PACKAGE)),1)
$(error The target passed to Makefile.build should refer to a single package)
endif

ifeq ($(PACKAGE),)
$(error The target passed to Makefile.build should refer to a package)
endif

include Makefile.$(PACKAGE)

# * Target to build

.PHONY: $(PACKAGE) $(PACKAGE)-uninstall install-$(PACKAGE)-to-stow

$(PACKAGE): ~/.local/$(LOCAL_TARGET_PATH)

# The next target is a symlink. Note that to compare modification times (of
# target and prerequisites), ~make~ looks at the mtime of the /destination of
# the symlink/. However it /does/ check whether the symlink exists so if the
# symlink is not present, ~make~ executes the commands for that target.

# In an earlier version, the prerequisite of the next target was
# $(PACKAGE_STOW_DIR). That directory has an mtime that is at least the mtime of
# $(PACKAGE_STOW_DIR)/$(LOCAL_TARGET_PATH), which is the destination of the
# (target) symlink. For all intents and purposes this meant that the target was
# always out-of-date and the Stow command would always execute.

~/.local/$(LOCAL_TARGET_PATH): $(PACKAGE_STOW_DIR)/$(LOCAL_TARGET_PATH)
	# Install $(PACKAGE) using Stow
	stow $(PACKAGE_NAME_VERSION)

# The next target not just removes the symlinks that Stow creates, it also
# deletes the directory for $(PACKAGE) from the Stow directory. To be on the
# safe side, this command asks the user for confirmation.

$(PACKAGE)-uninstall:
	# Uninstall $(PACKAGE) using Stow
	stow --delete $(PACKAGE_NAME_VERSION) --target=$(HOME)/.local
	# Delete $(PACKAGE) from Stow directory
	rm -rfI $(PACKAGE_STOW_DIR)

# The next target allows us to remove the files from $(PACKAGE_DIR) that are
# required to build and install $(PACKAGE) (to save disk space). A "make $(PACKAGE)" will
# only recreate $(PACKAGE)-related files in $(PACKAGE_DIR) when
# $(PACKAGE_STOW_DIR)/$(LOCAL_TARGET_PATH) doesn't exist.

$(PACKAGE_STOW_DIR)/$(LOCAL_TARGET_PATH):
	@$(MAKE) -f Makefile.build --no-print-directory install-$(PACKAGE)-to-stow

install-$(PACKAGE)-to-stow: $(PACKAGE_ARCHIVE_DIR)/$(ARCHIVE_TARGET_PATH)
	# Install $(PACKAGE) to Stow directory
	cd $(PACKAGE_ARCHIVE_DIR) && make install

$(PACKAGE_ARCHIVE_DIR)/$(ARCHIVE_TARGET_PATH): $(PACKAGE_ARCHIVE_DIR)/configure
	# Configure $(PACKAGE) build
	cd $(PACKAGE_ARCHIVE_DIR) && ./configure $(CONFIGURE_OPTIONS) --prefix=$(PACKAGE_STOW_DIR)
	# Build $(PACKAGE)
	cd $(PACKAGE_ARCHIVE_DIR) && make

# The next target also updates the timestamp of the target file, which is one of
# the uncompressed files. In this way the archive is only uncompressed once as
# the timestamp of the archive is older.

$(PACKAGE_ARCHIVE_DIR)/configure: $(PACKAGE_DIR)/$(PACKAGE_ARCHIVE)
	# Uncompress $(PACKAGE) source package
	tar xzf $< -C $(PACKAGE_DIR)
	@touch $@

$(PACKAGE_DIR)/$(PACKAGE_ARCHIVE): | $(PACKAGE_DIR)
	# Download $(PACKAGE) version $(PACKAGE_VERSION)
	wget $(WGET_OPTIONS) $(PACKAGE_URL)/$(PACKAGE_ARCHIVE)
